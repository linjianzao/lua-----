2.0 类型和值

lua的类型：nil, boolean, number, string, userdata,function, thread, and table

print(type("Hello world")) --> string
print(type(10.4*3)) --> number
print(type(print)) --> function
print(type(type)) --> function
print(type(true)) --> boolean
print(type(nil)) --> nil
print(type(type(X))) --> string
最后一行X 不管是什么值，结果都是string 因为结果的类型是string

变量没有预定义类型，任何变量都可以接收任何类型

print(type(a)) --> nil ('a' is not initialized)
a = 10
print(type(a)) --> number
a = "a string!!"
print(type(a)) --> string
a = print -- yes, this is valid!
a(type(a)) --> function
注意最后两行，是函数。在lua里 函数也是一种变量，可以和其他值一样使用它。
  当你在两种类型中使用同一个变量有可能会结果是乱码。

2.1 nil
  nil 不等于任何其他值。lua使用nil表示不可用值类型。全局变量还没分配值的时候的默认值是nil。你可以用nil去删除一个全局变量
  
2.2 Booleans
  boolean类型有两个值，false 和 true。条件 和nil 是false 其他任何值都是true 也就是说0，“”都是true
  
2.3 Number
  number代表实数。lua没有integer类型
  一些人会担心浮点型会引起自增或者对比 会出现奇怪的结果，实际上，不会这样。
  事实上所有现有的平台都遵照IEEE 754 浮点型标准。根据这个标准，会引起错误的唯一原因是number没有精确的标示。
  所以任何number的操作必须明确的给返回值。
  任何integer到2^53(近似10^16)，相当于单精度和双精度的数字。当你使用双精度代表一个整型，不会四舍五入，除非值大于2^53。
  lua 的number可以代表任何32-bit整型，不会出现错误。
  当然，有部分小数会错误。这种情况 和 使用纸和笔计算没什么不一样。如果我们要用小数表示1/7,我们必须在某个地方停止。
  使用十位表示1/7,结果是0.142857142。如果用十位数计算1/7×7，结果会是0.999999994而不是1。
  number在二进制使用有穷表示小数的无穷。例如：12.7-20+7.3 用双精度计算的结果值不是0,因为12.7和7.3在二进制里都不是有穷的。
  
  integers是有穷的，并且没有精度的错误。
  大部分CPU计算浮点型和整型的速度一样快。然而lua很容易把其他类型编译成number，比如单精度或多浮点。这可以在不支持浮点型的硬件平台上支持浮点型,比如嵌入式系统。
  可以查看luaconf.h了解详情
  我们可以把数字部分和小数部门分开写
  4 0.4 4.57e-3 0.3e12 5E+20
  另外也可以用16进制表示，16进制也有小数部分和二进制指数，比如：
  0xff (255) 0x1A3 (419) 0x0.2 (0.125) 0x1p-1 (0.5)
  0xa.bp2 (42.75)
  
  
  
